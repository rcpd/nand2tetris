// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/12/Memory.jack

/**
 * This library provides two services: direct access to the computer's main
 * memory (RAM), and allocation and recycling of memory blocks. The Hack RAM
 * consists of 32,768 words, each holding a 16-bit binary number.
 */ 
class Memory {
    static Array static0;

    /** Initializes the class. */
    function void init() {
        let static0 = 0; // manually assign pointer value as zero
        let static0[2048] = 14334; // 2048 = heap start, 16383=heap end (14334+2048+1 = 163823)
        let static0[2049] = 2050; // 2050 = next free block?
        return;
    }

    /** Returns the RAM value at the given address. */
    function int peek(int address) {
        return static0[address];
    }

    /** Sets the RAM value at the given address to the given value. */
    function void poke(int address, int value) {
        let static0[address] = value;
        return;
    }

    /** Finds an available RAM block of the given size and returns
     *  a reference to its base address. */
    function int alloc(int size) {
        var Array heapPtr; // heap size remaining?
        var int freePtr;

        if (size < 0) {
            do Sys.error(5); // Allocated memory size must be positive
        }

        if (size = 0) {
            let size = 1; // min allocation is 1
        }

        let heapPtr = 2048; // heapStart
        // heapPtr[0]{2048} = blocksFree(14334)
        // heapPtr[1]{2049} = freePtr(2050)
        // heapPtr[2]{2050} = freeBlock

        // while heapPtr in bounds and blocksFree < size
        // 1st alloc (non-max size): true
        while ((heapPtr < 16383) & (heapPtr[0] < size) ) {
            let freePtr = heapPtr[1]; // {2049} = 2050 (freeBlock)

            // if no blocksFree or freePtr at end of heap or freePtr referencing at empty block
            // 1st alloc (non-max size): true
            if ((heapPtr[0] = 0) | (freePtr > 16382) | (freePtr[0] = 0)) {
                let heapPtr = freePtr; // {2048} = 2050 (freeBlock)
            }

            // TODO
            else {
                let heapPtr[0] = (heapPtr[1] - heapPtr) + freePtr[0];

                if (freePtr[1] = (freePtr + 2)) {
                    let heapPtr[1] = heapPtr + 2;
                }
                else {
                    let heapPtr[1] = freePtr[1];
                }
            }
        }

        // TODO: why 4 words?
        if ((heapPtr + size) > 16379) {
            do Sys.error(6); // Heap overflow
        }

        // 1st alloc (non-max size): {2050} > size+2 (false)
        // TODO
        if (heapPtr[0] > (size + 2)) {
            let heapPtr[size + 2] = heapPtr[0] - size - 2;

            if (heapPtr[1] = (heapPtr + 2)) {
                let heapPtr[size + 3] = heapPtr + size + 4;
            }
            else {
                let heapPtr[size + 3] = heapPtr[1];
            }

            let heapPtr[1] = heapPtr + size + 2;
        }

        // return first word after linked list?
        // 1st alloc (non-max size): {2050} = 0 (no effect), {2051} also 0
        // 1st alloc (non-max size): return 2052
        let heapPtr[0] = 0;
        return heapPtr + 2;
    }

    /** De-allocates the given object (cast as an array) by making
     *  it available for future allocations. */
    function void deAlloc(Array o) {
        return; // placeholder
    }
}
