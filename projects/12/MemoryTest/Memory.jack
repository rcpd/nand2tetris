// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/12/Memory.jack

/**
 * This library provides two services: direct access to the computer's main
 * memory (RAM), and allocation and recycling of memory blocks. The Hack RAM
 * consists of 32,768 words, each holding a 16-bit binary number.
 */ 
class Memory {
    static Array static0;

    /** Initializes the class. */
    function void init() {
        let static0 = 0; // manually assign pointer value as zero
        // 2048 = first heap, 16383 = last heap
        let static0[2048] = 14334; // blockSize (size+2)
        let static0[2049] = 2050; // *nextPtr = &blockData
        // static0[2050] = 0; // &blockData (**nextPtr = null)
        return;
    }

    /** Returns the RAM value at the given address. */
    function int peek(int address) {
        return static0[address];
    }

    /** Sets the RAM value at the given address to the given value. */
    function void poke(int address, int value) {
        let static0[address] = value;
        return;
    }

    /** Finds an available RAM block of the given size and returns
     *  a reference to its base address. */
    function int alloc(int size) {
        var Array blockPtr;
        var int nextBlock;

        if (size < 0) {
            do Sys.error(5); // Allocated memory size must be positive
        }

        if (size = 0) {
            let size = 1; // min allocation is 1
        }

        let blockPtr = 2048; // start of heap

        // search from start of heap until suitable free block (first fit) or heap exhausted
        // 1st alloc: always false if size < maxSize (entire heap is freeBlock)
        // 2nd+ alloc: always true on first loop (initial blockSize == 0)
        // 2nd+ alloc: break when out of bounds or found a block with blockSize > size required
        while ((blockPtr < 16383) & (blockPtr[0] < size)) {
            
            // 2nd alloc 1st loop:
            // {2048} = 0 allocBlockSize (*blockPtr, &allocBlock)
            // {2049} = 2051 *allocNextPtr
            // {2050} = <allocBlockData>
            // {2051} = 14331 freeBlockSize (&freeBlock)
            // {2052} = 2053 *freeNextPtr (**null)
            // {2053} = <freeBlockData>

            // 2nd alloc 1st loop: *nextBlock = 2051
            let nextBlock = blockPtr[1];

            // if blockSize/nextBlockSize is zero or *nextBlock would exceed heap boundary
            // 2nd alloc 1st loop: true (blockSize == 0)
            if ((blockPtr[0] = 0) | (nextBlock > 16382) | (nextBlock[0] = 0)) {
                // 2nd alloc 1st loop: *blockPtr = 2051
                let blockPtr = nextBlock; // advance to next block & continue
            }

            // TODO: unsure when entered
            else { // if blockSize/nextBlockSize is not zero
                // update blockSize & *nextPtr

                // blockSize = (&blockData - *blockPtr) + nextBlockSize
                let blockPtr[0] = (blockPtr[1] - blockPtr) + nextBlock[0];

                // if **(nextPtr+1) == &blockData
                if (nextBlock[1] = (nextBlock + 2)) {
                    // *nextPtr = &blockData+2
                    let blockPtr[1] = blockPtr + 2;
                }
                else {
                    // *nextPtr = *nextBlockPtr
                    let blockPtr[1] = nextBlock[1];
                }
            }
        }

        // error if loop was broken by exhausting heap / going out of bounds
        // minimum (3 + size) words required to continue (blockSize, *nextPtr, freeBlockSize)
        if ((blockPtr + size) > 16379) {
            do Sys.error(6); // Heap overflow
        }
        
        // if blockSize is sufficient split into allocBlock & freeBlock
        if (blockPtr[0] > (size + 2)) {           
            // freeBlockSize = blockSize - allocBlockSize
            let blockPtr[size + 2] = blockPtr[0] - size - 2;
            
            // 1st alloc (1): {2051} = 14331
            // 2nd alloc (1):
            // {2051} = 14331 allocBlockSize (*blockPtr, &allocBlock)
            // {2052} = 2053 *allocNextPtr
            // {2053} = <allocBlockData>
            // {2054} = 14328 freeBlockSize (&freeBlock)
            // {2055} = <freeNextPtr>
            // {2056} = <freeBlockData>

            // if *allocNextPtr == &allocBlockData (i.e. *allocNextPtr has not been updated)
            // TODO: what case causes it to be updated?
            if (blockPtr[1] = (blockPtr + 2)) {
                // *freeNextPtr = &freeBlockData (**null)
                let blockPtr[size + 3] = blockPtr + size + 4;
                
                // 1st alloc (1):
                // {2048} = 14334 allocBlockSize (*blockPtr, &allocBlock)
                // {2049} = 2050 allocNextPtr
                // {2050} = <allocBlockData>
                // {2051} = 14331 freeBlockSize (&freeBlock)
                // {2052} = 2053 freeNextPtr (**null)
                // {2053} = <freeBlockData>
                
                // 2nd alloc (1):
                // {2051} = 14331 allocBlockSize (*blockPtr, &allocBlock)
                // {2052} = 2053 *allocNextPtr
                // {2053} = <allocBlockData>
                // {2054} = 14328 freeBlockSize (&freeBlock)
                // {2055} = 2056 *freeNextPtr (**null)
                // {2056} = <freeBlockData>
                
            }
            else {
                // *freeNextPtr = *allocNextPtr
                let blockPtr[size + 3] = blockPtr[1];
            }

            // *allocNextPtr = &freeBlock
            let blockPtr[1] = blockPtr + size + 2;

            // 2nd alloc (1):
            // {2051} = 14331 allocBlockSize (*blockPtr, &allocBlock)
            // {2052} = 2054 *allocNextPtr
            // {2053} = <allocBlockData>
            // {2054} = 14328 freeBlockSize (&freeBlock)
            // {2055} = 2056 *freeNextPtr (**null)
            // {2056} = <freeBlockData>
        }

        let blockPtr[0] = 0; // allocBlockSize = 0, flagging it as allocated
        return blockPtr + 2; // return &allocBlockData

        // 2nd alloc (1):
        // {2051} = 0 allocBlockSize (*blockPtr, &allocBlock)
        // {2052} = 2054 *allocNextPtr
        // {2053} = <allocBlockData>
        // {2054} = 14328 freeBlockSize (&freeBlock)
        // {2055} = 2056 *freeNextPtr (**null)
        // {2056} = <freeBlockData>
    }

    /** De-allocates the given object (cast as an array) by making
     *  it available for future allocations (appended to end of freeList) */
    function void deAlloc(Array o) {
        var Array blockPtr;
        var int nextPtr;

        let blockPtr = o - 2; // move backwards from &allocBlockData to start of *allocBlock header
        let nextPtr = blockPtr[1]; // *nextPtr

        // if *nextPtr references a consumed block update current block in place as available
        // **nextPtr == 0 // allocBlockSize
        if (nextPtr[0] = 0) {
            // restore allocBlockSize (allocBlockSize = *allocNextPtr - *blockPtr - 2)
            let blockPtr[0] = blockPtr[1] - blockPtr - 2;

            // fabricated example
            // {2051} = 1 allocBlockSize (*blockPtr, &allocBlock)
            // {2052} = 2054 *allocNextPtr
            // {2053} = <allocBlockData>
            // {2054} = 0 allocBlockSize2 (&allocBlock2)
            // {2055} = 2056 *allocNextPtr2 (**null)
            // {2056} = <allocBlockData2>
        }
        else { // if *nextPtr references a free block append this block to it

            // set the size to the current block + total size of the adjacent free block
            // allocBlockSize = *allocNextPtr - *blockPtr + **allocNextPtr
            let blockPtr[0] = blockPtr[1] - blockPtr + nextPtr[0];

            // 2nd alloc (1):
            // {2051} = 14331 allocBlockSize (*blockPtr, &allocBlock)
            // {2052} = 2054 *allocNextPtr
            // {2053} = <allocBlockData>
            // {2054} = // 14328 freeBlockSize (&freeBlock)
            // {2055} = // 2056 *freeNextPtr (**null)
            // {2056} = // <freeBlockData>

            // if nextBlock was end of freeList (**(nextPtr+1) == nextPtr+2)
            if (nextPtr[1] = (nextPtr + 2)) {
                // *allocNextPtr = &allocBlockData (&allocBlock is now effectively &freeBlock)
                let blockPtr[1] = blockPtr + 2;

                // 2nd alloc (1):
                // {2051} = 14331 freeBlockSize (*blockPtr, &freeBlock)
                // {2052} = 2053 *freeNextPtr (**null)
                // {2053} = <freeBlockData>
            }
            else { // if nextBlock was another freed block

                // *allocNextPtr = **(nextPtr+1)
                let blockPtr[1] = nextPtr[1];

                // TODO: does *freeNextPtr == first or last freeBlockData when multiple?
                // fabricated example
                // {2051} = 4 freeBlockSize (*blockPtr, &freeBlock)
                // {2052} = 2056 *freeNextPtr
                // {2053} = // <freeBlockData>
                // {2054} = // 1 freeBlockSize2 (&freeBlock2)
                // {2055} = // 2056 *freeNextPtr2 (**null)
                // {2056} = <freeBlockData2>
            }
        }
        return;
    }
}
