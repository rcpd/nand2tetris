0 @LCL 
  // push local 0 
  // function SimpleFunction.test 2 
  // (SimpleFunction.test) 
  EVAL: A=1 
  A=1 D=0 M=317
1 D=M 
  EVAL: D=317 (317) 
  A=1 D=317 M=317
2 @0 
  EVAL: A=0 
  A=0 D=317 M=317
3 A=D+A 
  EVAL: A=317 (317+0) 
  A=317 D=317 M=0
4 D=M 
  EVAL: D=0 (0) 
  A=317 D=0 M=0
5 @SP 
  EVAL: A=0 
  A=0 D=0 M=317
6 A=M 
  EVAL: A=317 (317) 
  A=317 D=0 M=0
7 M=D 
  EVAL: M=0 (0) 
  A=317 D=0 M=0
8 @SP 
  EVAL: A=0 
  A=0 D=0 M=317
9 M=M+1 
  EVAL: M=318 (317+1) 
  A=0 D=0 M=318
10 @LCL 
  // push local 1 
  EVAL: A=1 
  A=1 D=0 M=317
11 D=M 
  EVAL: D=317 (317) 
  A=1 D=317 M=317
12 @1 
  EVAL: A=1 
  A=1 D=317 M=317
13 A=D+A 
  EVAL: A=318 (317+1) 
  A=318 D=317 M=0
14 D=M 
  EVAL: D=0 (0) 
  A=318 D=0 M=0
15 @SP 
  EVAL: A=0 
  A=0 D=0 M=318
16 A=M 
  EVAL: A=318 (318) 
  A=318 D=0 M=0
17 M=D 
  EVAL: M=0 (0) 
  A=318 D=0 M=0
18 @SP 
  EVAL: A=0 
  A=0 D=0 M=318
19 M=M+1 
  EVAL: M=319 (318+1) 
  A=0 D=0 M=319
20 @SP 
  // add 
  EVAL: A=0 
  A=0 D=0 M=319
21 M=M-1 
  EVAL: M=318 (319-1) 
  A=0 D=0 M=318
22 A=M 
  EVAL: A=318 (318) 
  A=318 D=0 M=0
23 D=M 
  EVAL: D=0 (0) 
  A=318 D=0 M=0
24 @SP 
  EVAL: A=0 
  A=0 D=0 M=318
25 M=M-1 
  EVAL: M=317 (318-1) 
  A=0 D=0 M=317
26 A=M 
  EVAL: A=317 (317) 
  A=317 D=0 M=0
27 M=D+M 
  EVAL: M=0 (0+0) 
  A=317 D=0 M=0
28 @SP 
  EVAL: A=0 
  A=0 D=0 M=317
29 M=M+1 
  EVAL: M=318 (317+1) 
  A=0 D=0 M=318
30 @SP 
  // not 
  EVAL: A=0 
  A=0 D=0 M=318
31 M=M-1 
  EVAL: M=317 (318-1) 
  A=0 D=0 M=317
32 A=M 
  EVAL: A=317 (317) 
  A=317 D=0 M=0
33 M=!M 
  EVAL: M=-1 (~0) 
  A=317 D=0 M=-1
34 @SP 
  EVAL: A=0 
  A=0 D=0 M=317
35 M=M+1 
  EVAL: M=318 (317+1) 
  A=0 D=0 M=318
36 @ARG 
  // push argument 0 
  EVAL: A=2 
  A=2 D=0 M=310
37 D=M 
  EVAL: D=310 (310) 
  A=2 D=310 M=310
38 @0 
  EVAL: A=0 
  A=0 D=310 M=318
39 A=D+A 
  EVAL: A=310 (310+0) 
  A=310 D=310 M=1234
40 D=M 
  EVAL: D=1234 (1234) 
  A=310 D=1234 M=1234
41 @SP 
  EVAL: A=0 
  A=0 D=1234 M=318
42 A=M 
  EVAL: A=318 (318) 
  A=318 D=1234 M=0
43 M=D 
  EVAL: M=1234 (1234) 
  A=318 D=1234 M=1234
44 @SP 
  EVAL: A=0 
  A=0 D=1234 M=318
45 M=M+1 
  EVAL: M=319 (318+1) 
  A=0 D=1234 M=319
46 @SP 
  // add 
  EVAL: A=0 
  A=0 D=1234 M=319
47 M=M-1 
  EVAL: M=318 (319-1) 
  A=0 D=1234 M=318
48 A=M 
  EVAL: A=318 (318) 
  A=318 D=1234 M=1234
49 D=M 
  EVAL: D=1234 (1234) 
  A=318 D=1234 M=1234
50 @SP 
  EVAL: A=0 
  A=0 D=1234 M=318
51 M=M-1 
  EVAL: M=317 (318-1) 
  A=0 D=1234 M=317
52 A=M 
  EVAL: A=317 (317) 
  A=317 D=1234 M=-1
53 M=D+M 
  EVAL: M=1233 (1234+-1) 
  A=317 D=1234 M=1233
54 @SP 
  EVAL: A=0 
  A=0 D=1234 M=317
55 M=M+1 
  EVAL: M=318 (317+1) 
  A=0 D=1234 M=318
56 @ARG 
  // push argument 1 
  EVAL: A=2 
  A=2 D=1234 M=310
57 D=M 
  EVAL: D=310 (310) 
  A=2 D=310 M=310
58 @1 
  EVAL: A=1 
  A=1 D=310 M=317
59 A=D+A 
  EVAL: A=311 (310+1) 
  A=311 D=310 M=37
60 D=M 
  EVAL: D=37 (37) 
  A=311 D=37 M=37
61 @SP 
  EVAL: A=0 
  A=0 D=37 M=318
62 A=M 
  EVAL: A=318 (318) 
  A=318 D=37 M=1234
63 M=D 
  EVAL: M=37 (37) 
  A=318 D=37 M=37
64 @SP 
  EVAL: A=0 
  A=0 D=37 M=318
65 M=M+1 
  EVAL: M=319 (318+1) 
  A=0 D=37 M=319
66 @SP 
  // sub 
  EVAL: A=0 
  A=0 D=37 M=319
67 M=M-1 
  EVAL: M=318 (319-1) 
  A=0 D=37 M=318
68 A=M 
  EVAL: A=318 (318) 
  A=318 D=37 M=37
69 D=M 
  EVAL: D=37 (37) 
  A=318 D=37 M=37
70 @SP 
  EVAL: A=0 
  A=0 D=37 M=318
71 M=M-1 
  EVAL: M=317 (318-1) 
  A=0 D=37 M=317
72 A=M 
  EVAL: A=317 (317) 
  A=317 D=37 M=1233
73 M=M-D 
  EVAL: M=1196 (1233-37) 
  A=317 D=37 M=1196
74 @SP 
  EVAL: A=0 
  A=0 D=37 M=317
75 M=M+1 
  EVAL: M=318 (317+1) 
  A=0 D=37 M=318
76 @ARG 
  // pop argument 0 
  // return 
  // move result to ARG[0] (soon to be last stack item) 
  EVAL: A=2 
  A=2 D=37 M=310
  RETURN: REMOVE FROM CALL TREE (PRE-RETURN)

  RETURN: REMOVE FROM CALL TREE (PRE-RETURN)

77 D=M 
  EVAL: D=310 (310) 
  A=2 D=310 M=310
78 @0 
  EVAL: A=0 
  A=0 D=310 M=318
79 D=D+A 
  EVAL: D=310 (310+0) 
  A=0 D=310 M=318
80 @SP 
  EVAL: A=0 
  A=0 D=310 M=318
81 A=M 
  EVAL: A=318 (318) 
  A=318 D=310 M=37
82 M=D 
  EVAL: M=310 (310) 
  A=318 D=310 M=310
83 @SP 
  EVAL: A=0 
  A=0 D=310 M=318
84 M=M-1 
  EVAL: M=317 (318-1) 
  A=0 D=310 M=317
85 A=M 
  EVAL: A=317 (317) 
  A=317 D=310 M=1196
86 D=M 
  EVAL: D=1196 (1196) 
  A=317 D=1196 M=1196
87 @SP 
  EVAL: A=0 
  A=0 D=1196 M=317
88 M=M+1 
  EVAL: M=318 (317+1) 
  A=0 D=1196 M=318
89 A=M 
  EVAL: A=318 (318) 
  A=318 D=1196 M=310
90 A=M 
  EVAL: A=310 (310) 
  A=310 D=1196 M=1234
91 M=D 
  EVAL: M=1196 (1196) 
  A=310 D=1196 M=1196
92 @SP 
  EVAL: A=0 
  A=0 D=1196 M=318
93 M=M-1 
  EVAL: M=317 (318-1) 
  A=0 D=1196 M=317
94 @ARG 
  // *ARG[0] 
  // return: discard the callee stack leaving result in ARG[0] and SP at ARG[0]+1 
  EVAL: A=2 
  A=2 D=1196 M=310
95 D=M+1 
  // d = *ARG[0]+1 
  // whether this is ARG[1] (2+ args) or RIP doesn't matter 
  EVAL: D=311 (310+1) 
  A=2 D=311 M=310
96 @SP 
  // *esp 
  // as the intent is to discard everything after result at this point 
  EVAL: A=0 
  A=0 D=311 M=317
97 M=D 
  // [esp] = *ARG[0]+1 
  EVAL: M=311 (311) 
  A=0 D=311 M=311
98 @LCL 
  // *LCL 
  // return: restore caller stack (THAT) 
  EVAL: A=1 
  A=1 D=311 M=317
99 A=M-1 
  // *LCL-1 (**THAT) 
  EVAL: A=316 (317-1) 
  A=316 D=311 M=4010
100 D=M 
  // d = [LCL-1] (*THAT) 
  EVAL: D=4010 (4010) 
  A=316 D=4010 M=4010
101 @THAT 
  EVAL: A=4 
  A=4 D=4010 M=4000
102 M=D 
  // [THAT] = [LCL-1] (*THAT) 
  EVAL: M=4010 (4010) 
  A=4 D=4010 M=4010
103 @2 
  // return: restore caller stack (THIS) 
  EVAL: A=2 
  A=2 D=4010 M=310
104 D=A 
  // d=2 
  EVAL: D=2 (2) 
  A=2 D=2 M=310
105 @LCL 
  // *LCL 
  EVAL: A=1 
  A=1 D=2 M=317
106 A=M-D 
  // *LCL-2 (**THIS) 
  EVAL: A=315 (317-2) 
  A=315 D=2 M=3010
107 D=M 
  // d = [LCL-2] (*THIS) 
  EVAL: D=3010 (3010) 
  A=315 D=3010 M=3010
108 @THIS 
  EVAL: A=3 
  A=3 D=3010 M=3000
109 M=D 
  // [THIS] = [LCL-2] (*THIS) 
  EVAL: M=3010 (3010) 
  A=3 D=3010 M=3010
110 @3 
  // return: restore caller stack (ARG) 
  EVAL: A=3 
  A=3 D=3010 M=3010
111 D=A 
  // d=3 
  EVAL: D=3 (3) 
  A=3 D=3 M=3010
112 @LCL 
  // *LCL 
  EVAL: A=1 
  A=1 D=3 M=317
113 A=M-D 
  // *LCL-3 (**ARG) 
  EVAL: A=314 (317-3) 
  A=314 D=3 M=300
114 D=M 
  // d = [LCL-3] (*ARG) 
  EVAL: D=300 (300) 
  A=314 D=300 M=300
115 @ARG 
  EVAL: A=2 
  A=2 D=300 M=310
116 M=D 
  // [ARG] = [LCL-3] (*ARG) 
  EVAL: M=300 (300) 
  A=2 D=300 M=300
117 @LCL 
  // *LCL 
  // before restoring LCL, save it at R13 
  EVAL: A=1 
  A=1 D=300 M=317
118 D=M 
  // d = [LCL] 
  EVAL: D=317 (317) 
  A=1 D=317 M=317
119 @R13 
  // *R13 
  EVAL: A=13 
  A=13 D=317 M=0
120 M=D 
  // [R13] = [LCL] 
  EVAL: M=317 (317) 
  A=13 D=317 M=317
121 @4 
  // return: restore caller stack (LCL) 
  EVAL: A=4 
  A=4 D=317 M=4010
122 D=A 
  // d=4 
  EVAL: D=4 (4) 
  A=4 D=4 M=4010
123 @LCL 
  // *LCL 
  EVAL: A=1 
  A=1 D=4 M=317
124 A=M-D 
  // *LCL-4 (**LCL) 
  EVAL: A=313 (317-4) 
  A=313 D=4 M=305
125 D=M 
  // d = [LCL-4] (*LCL) 
  EVAL: D=305 (305) 
  A=313 D=305 M=305
126 @LCL 
  EVAL: A=1 
  A=1 D=305 M=317
127 M=D 
  // [LCL] = [LCL-4] (*LCL) 
  EVAL: M=305 (305) 
  A=1 D=305 M=305
128 @5 
  // return: unconditional jump to LCL-5 (RIP) 
  EVAL: A=5 
  A=5 D=305 M=0
129 D=A 
  // d=5 
  EVAL: D=5 (5) 
  A=5 D=5 M=0
130 @R13 
  // *R13 (old *LCL) 
  EVAL: A=13 
  A=13 D=5 M=317
131 A=M-D 
  // *LCL-5 (*LCL) 
  EVAL: A=312 (317-5) 
  A=312 D=5 M=1000
132 A=M 
  // d = [LCL-5] (*LCL) 
  EVAL: A=1000 (1000) 
  A=1000 D=5 M=0
999 0;JMP 
  // return (jump to RIP) 
  EVAL: A=1000 
  A=1000 D=5 M=0
